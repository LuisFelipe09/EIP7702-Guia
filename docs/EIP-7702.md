# EIP-7702: Potenciando las Cuentas de Propiedad Externa (EOA) con Código

La **EIP-7702: Set Code for EOAs** es una propuesta de mejora de Ethereum que introduce un **nuevo tipo de transacción EIP-2718, identificado como `0x04`**. Su objetivo principal es permitir a las **Cuentas de Propiedad Externa (EOA) establecer código en sus propias cuentas de forma permanente**. Esta EIP busca transformar la experiencia de usuario (UX) en Ethereum, abordando limitaciones de las EOAs actuales al habilitar funcionalidades que hasta ahora eran exclusivas de los contratos inteligentes.

## 1. Motivación Principal: Mejoras en la Experiencia de Usuario (UX)

La EIP-7702 se enfoca en añadir funcionalidades a corto plazo para superar las barreras de adopción de mejoras de UX para las EOAs y permitir que estas se permeen a través de toda la pila de aplicaciones. Habilita tres características clave:

*   **Procesamiento por lotes (Batching)**: Permite realizar **múltiples operaciones de un mismo usuario en una única transacción atómica**. Un ejemplo común es la aprobación de un token ERC-20 seguida de su gasto en una sola transacción, lo cual hoy requiere dos.
*   **Patrocinio (Sponsorship)**: Habilita que **una cuenta (X) pague las tarifas de gas en nombre de otra (Y)**. Esto puede ser útil para aplicaciones que desean subsidiar los costos de sus usuarios o para servicios que aceptan pagos en otros tokens. También permite el **auto-patrocinio (self-sponsoring)**, donde `tx.origin` puede establecer y ejecutar su propio código delegado.
*   **Reducción de privilegios (Privilege de-escalation)**: Permite a los usuarios firmar subclaves con **permisos específicos y más restrictivos** que el acceso global a su cuenta. Por ejemplo, se puede otorgar permiso para gastar tokens ERC-20, pero no ETH, limitar el gasto diario a un porcentaje, o interactuar solo con una aplicación específica.

## 2. Funcionamiento Técnico Detallado

La EIP-7702 introduce el concepto de **delegación de código** para las EOAs a través de un nuevo tipo de transacción:

*   **Nuevo Tipo de Transacción**: Un nuevo tipo de transacción EIP-2718, identificado como `0x04`, que incluye una lista de autorizaciones y un mecanismo de firma.
*   **Lista de Autorizaciones (`authorization_list`)**: La transacción incluye una `authorization_list`, que es una lista de tuplas con el formato `[chain_id, address, nonce, y_parity, r, s]`. Cada tupla indica el código que el firmante desea ejecutar en el contexto de su EOA.
    *   Esta lista se procesa **antes de la ejecución** de la porción principal de la transacción, pero después de que el nonce del remitente se incrementa. La transacción es inválida si la `authorization_list` está vacía.
    *   Por cada tupla, se verifican varios parámetros (ID de cadena, nonce, longitud de la dirección, etc.) y se recupera la `authority` (dirección del firmante) usando `ecrecover`.
*   **Indicador de Delegación (`Delegation Indicator`)**: Para cada tupla de autorización válida, se escribe un **indicador de delegación** con el valor `0xef0100 || address` en el código de la cuenta autorizante. Este indicador utiliza el *opcode* `0xef` que está prohibido en EIP-3541.
    *   **Ejecución de Código Delegado**: Este indicador de delegación **fuerza a todas las operaciones de ejecución** (como `CALL`, `CALLCODE`, `DELEGATECALL`, `STATICCALL`, y cualquier transacción cuyo `destination` apunte a una dirección con un indicador de delegación) a **cargar y ejecutar el código apuntado por esa dirección** en el contexto de la EOA autorizante.
    *   **Persistencia de la Delegación**: Es crucial entender que, si la ejecución de una transacción falla (ej. por una condición excepcional o `revert`), los indicadores de delegación procesados **no se revierten**.
    *   **`CODESIZE` vs. `EXTCODESIZE`**: Cuando se ejecuta una cuenta delegada, `EXTCODESIZE` devuelve el tamaño del indicador de delegación (23 bytes), mientras que `CODESIZE` devuelve el tamaño del código real residiendo en la dirección delegada.
    *   **Creación por Plantilla**: Los usuarios especifican el código que desean ejecutar mediante un **puntero a una dirección de código ya desplegado en la cadena**, en lugar de incluir el bytecode directamente en la transacción. Esto es más eficiente y evita la creación de nuevas capacidades únicas para las EOAs.
    *   **Sin `Initcode`**: La propuesta **no incluye un mecanismo de `initcode`** para las EOAs. La inicialización debe realizarse mediante una llamada estándar a la EOA después de la delegación, lo que implica que no es atómica con la configuración del código.
    *   **Limpieza de Delegación**: Es posible restaurar una EOA a su estado original delegando a la dirección `0x0000000000000000000000000000000000000000`, lo que borra el código de la cuenta.

### Comportamiento de `msg.sender` con Delegación (Ejemplo de Foundry)

Un test de Foundry (`DelegationTest`) ilustra cómo cambia `msg.sender` en las interacciones delegadas.

1.  **Bob delega al `CallerContract`**: Se usa `vm.signAndAttachDelegation(address(caller), BOB_PK)` para dar permiso al `CallerContract` de actuar en nombre de `BOB_ADDRESS` (una EOA).
2.  **`BOB_ADDRESS` llama a `CallerContract`**: Cuando `BOB_ADDRESS` (simulando una transacción externa) llama a `CallerContract.callCallee()`:
    *   Dentro de `CallerContract.callCallee()`, **`msg.sender` es `BOB_ADDRESS`** (la EOA delegada).
3.  **`CallerContract` llama a `CalleeContract`**: Si `CallerContract` realiza una llamada interna a `CalleeContract`:
    *   Dentro de `CalleeContract`, **`msg.sender` es la dirección del `CallerContract`**.

Este ejemplo demuestra cómo la identidad de `msg.sender` se adapta a las capas de ejecución: la EOA delegada es el `msg.sender` inicial para la llamada externa al contrato delegado, y luego el contrato delegado actúa como `msg.sender` para sus propias llamadas internas.

## 3. Ruptura de Invariantes Existentes en el EVM

La EIP-7702, aunque innovadora, **rompe varios invariantes importantes del EVM** que los desarrolladores deben conocer:

*   **Saldo de EOA**: Anteriormente, el saldo de una cuenta solo podía disminuir como resultado de una transacción originada por ella misma. Con EIP-7702, **cualquier llamada a una EOA delegada puede causar que su saldo disminuya**.
*   **Nonce de EOA**: Antes, el nonce de una EOA no aumentaba después de que la ejecución de la transacción comenzaba. Ahora, una vez que una cuenta ha sido delegada, **puede invocar una operación de creación durante la ejecución, causando que el nonce aumente** intra-transacción.
*   **`tx.origin == msg.sender`**: Históricamente, esta equivalencia solo era cierta en el `frame` superior de ejecución. Con la delegación, **una EOA puede invocar múltiples llamadas por transacción, haciendo que `tx.origin == msg.sender` pueda no ser cierto en el `frame` superior de ejecución**. Esto afecta protecciones contra ataques de "atomic sandwich" (como flash loans) y guardas de reentrada que dependen de esta invariante. Los autores de la EIP consideran que estos riesgos son aceptables, dados los beneficios en la UX.

## 4. Consideraciones de Seguridad Críticas

La EIP-7702 introduce complejas implicaciones de seguridad que requieren una implementación cuidadosa:

*   **Advertencia Explícita**: Los autores de la EIP han advertido explícitamente: **"no hay una forma segura de proporcionar esta interfaz" directamente a los usuarios para firmar autorizaciones**.
*   **Control Completo de la EOA**: **Un delegado mal implementado puede permitir a un actor malicioso tomar casi el control completo de la EOA de un firmante**.
*   **Protecciones Esenciales en Contratos Delegados Seguros**: Los contratos delegados **deben implementar salvaguardias rigurosas y requerir una firma de la autoridad de la cuenta** sobre los siguientes elementos:
    *   **Protección contra repetición (Replay protection)**: Implementar un nonce y firmarlo para evitar que un actor malicioso reutilice una firma.
    *   **Validación de parámetros de transacción**: Parámetros como `value`, `gas`, `target` y `calldata` deben ser firmados. Sin esto, un patrocinador malicioso podría causar efectos inesperados, como hacer fallar la transacción o llamar funciones arbitrarias en contratos arbitrarios.
*   **Mitigación de Front-running en la Inicialización**: Dado que la EIP no permite `initcode` ni el establecimiento atómico de `storage`, los desarrolladores deben **verificar el `calldata` inicial para propósitos de configuración con `ecrecover`**. Esto asegura que la cuenta solo se inicialice con valores deseables y la protege de observadores que intenten manipular la inicialización.
*   **Gestión de Almacenamiento (Storage Management)**: Es crucial que los contratos delegados utilicen el almacenamiento de manera que **eviten colisiones accidentales al migrar de un delegado a otro**. Se pueden usar estándares como ERC-7201 o diseñar contratos especiales para limpiar el `storage`.
*   **Riesgos con `tx.origin`**: Permitir que el remitente de una EIP-7702 también establezca código puede **romper protecciones contra ataques "atomic sandwich" y guardas de reentrada** que dependen de `tx.origin`.
*   **Propagación de Transacciones**: La delegación plantea desafíos para la propagación de transacciones, ya que una EOA delegada puede invalidar transacciones de otras cuentas. Se recomienda que los clientes **no acepten más de una transacción pendiente para cualquier EOA con un indicador de delegación no cero**.

## 5. Compatibilidad con la Abstracción de Cuentas Futura (AA)

La EIP-7702 está diseñada para ser **compatible con la abstracción de cuentas (AA)**, sin sobre-especificar detalles de EIP-4337 o RIP-7560.

*   Permite que la dirección que los usuarios firman apunte directamente al código de `wallets` de EIP-4337 existentes.
*   Las EOAs pueden **mascararse como contratos** para ser incluidas en `bundles` de EIP-4337, de una manera compatible con el `EntryPoint` existente.
*   Esto ayuda a unificar los *workstreams* de desarrollo de UX, minimizando la fragmentación.

## Conclusión

La EIP-7702 representa un avance significativo para las Cuentas de Propiedad Externa en Ethereum, brindándoles funcionalidades avanzadas que mejoran la UX, como el procesamiento por lotes, el patrocinio de transacciones y la desescalada de privilegios. Sin embargo, esta transformación viene con **rupturas importantes de invariantes del EVM** y **consideraciones de seguridad críticas** que los desarrolladores deben comprender y abordar con rigor para implementar soluciones robustas y confiables. Su diseño con **delegación persistente** y **compatibilidad con la abstracción de cuentas futura** busca unificar los esfuerzos de mejora de UX en el ecosistema de Ethereum.

